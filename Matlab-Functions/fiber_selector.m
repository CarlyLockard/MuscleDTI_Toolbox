function [final_fibers, final_curvature, final_angle, final_distance, qual_mask, num_tracked, mean_fiber_properties, mean_apo_properties] = ...
    fiber_selector(fitted_fiber_all, angle_list, distance_list, curvature_list, n_points, apo_area, roi_flag, fs_options)
%
%FUNCTION fiber_selector
%  [final_fibers, final_curvature, final_angle, final_distance, qual_mask, num_tracked, mean_fiber_properties, mean_apo_properties] = ...
%    fiber_selector(fitted_fiber_all, angle_list, distance_list, curvature_list, n_points, apo_area, roi_flag, fs_options)
%
%USAGE
%  The function fiber_selector is used to reject outlying fiber tract data in
%  the MuscleDTI_Toolbox. The quality algorithm described in Heemskerk et al, 2008  
%  is implemented, but updated to account for the inclusion of curvature in the 
%  architectural computations. Specifically, the fibers are selected for having:
%    1) monotonically increasing values in the Z direction. This prevents errors due
%       to overfitting in the Z direction; 
%    2) minimum length (in mm, specified by the user based on their knowledge
%       of the expected muscle geometry);
%    3) reasonable pennation angles (in degrees, specified by user; a value of
%       0 (zero) is suggested;
%    4) reasonable curvature values (in m^-1, specified by user based on their knowledge
%       of the expected muscle geometry); and
%    5) within the 95% confidence interval for length, pennation angle, and
%       curvature set by the surrounding 24 tracts.
%
%INPUT ARGUMENTS 
%  fitted_fiber_all: the smoothed fiber tracts
%
%  angle_list: pennation angles for smoothed fiber tracts 
%
%  distance_list: distance measures for smoothed fiber tracts 
%
%  curvature_list: curvature measures for smoothed fiber tracts 
%
%  n_points: the number of points quantified per fiber tract 
%
%  apo_area: a matrix indicating the amount of aponeurosis area associated
%    with each fiber tract
%
%  roi_flag: a mask indicating fiber tracts that propagated at least one
%    point in teh function fiber_track.
%
%  fs_options: a structure containing user-specified criteria for rejecting
%    tracts:
%      min_distance: minimum distance for selected tracts, in mm
%      min_pennation: minimum pennation angle, in degrees 
%      max_pennation: maximum pennation angle, in degrees 
%      max_curvature: maximum curvature, in m^-1
%
%OUTPUT ARGUMENTS
%  final_fibers: the fiber tracts that passed all selection criteria
%
%  final_curvature: pointwise measurements of curvature for the final tracts.
%
%  final_angle: pointwise measurements of pennation angle for the final
%    tracts.
%
%  final_distance: pointwise measurements of cumulative distance for the
%    final tracts
%
%  qual_mask: a 3D matrix of the same row x column size as the roi_mesh, with 6
%    layers corresponding to each stage of the selection process. In each
%    layer, ones correspond to retained fibers and zeros correspond to
%    rejected fibers
%
%  num_tracked: the number of fibers for each of the following steps:
%    1) the number of potential fiber tracts;
%    2) the number of these tracts generated by fiber_track;
%    3-7) the number of fiber tracts that met criteria 1-5 above, respectively.
%
%  mean_fiber_properties: A 3D matrix (rows x columns x 5) containing the mean
%    curvature, pennation, and length values along each of the tracts; the
%    amount of aponeurosis area represented by each tract; and the number of
%    points in each tract
%
%  mean_apo_properties: A 1 x 3 vector containing the whole-muscle mean values
%    for curvature, pennation, and fiber tract length, weighted by the
%    amount of aponeurosis area represented by each tract.
%
%OTHER FUNCTIONS IN THE MUSCLE DTI FIBER-TRACKING TOOLBOX
%  For help defining the mask, see <a href="matlab: help define_muscle">define_muscle</a>.
%  For help defining the ROI, see <a href="matlab: help define_roi">define_roi</a>.
%  For help with the fiber tracking program, see <a href="matlab: help fiber_track">fiber_track</a>.
%  For help smoothing fiber tracts, see <a href="matlab: help fiber_smoother">fiber_smoother</a>.
%  For help quantifying fiber tracts, see <a href="matlab: help fiber_quantifier">fiber_quantifier</a>.
%  For help visualizing the data, see <a href="matlab: help fiber_visualizer">fiber_visualizer</a>.
%
%VERSION INFORMATION
%  v 0.1
%
%ACKNOWLEDGEMENTS
%  People: Zhaohua Ding, Anneriet Heemskerk
%  Grant support: NIH/NIAMS R01 AR050101, NIH/NIAMS R01 AR073831

%% get options from input structure
min_distance = fs_options.min_distance;
min_pennation = fs_options.min_pennation;
max_pennation = fs_options.max_pennation;
max_curvature = fs_options.max_curvature;

%% intialize output variables

fiber_indices_rows=sum(squeeze(angle_list(:,:,2)), 2);
fiber_indices_rows=fiber_indices_rows>0;
fiber_indices_cols=sum(squeeze(angle_list(:,:,2)), 1);
fiber_indices_cols=fiber_indices_cols>0;
first_row = find(fiber_indices_rows, 1);
last_row = find(fiber_indices_rows, 1, 'last');
first_col = find(fiber_indices_cols, 1);
last_col = find(fiber_indices_cols, 1, 'last');

final_fibers=zeros(size(fitted_fiber_all));
final_fibers(first_row:last_row, first_col:last_col, :, :) = fitted_fiber_all(first_row:last_row, first_col:last_col, :, :);
final_angle = angle_list;
final_distance = distance_list;
final_curvature = curvature_list;

initial_fibers = zeros(size(roi_flag));
initial_fibers(first_row:last_row, first_col:last_col)=1;
qual_mask = zeros([size(squeeze(fitted_fiber_all(:,:,1,1))) 6]);
qual_mask(:,:,1)=roi_flag.*initial_fibers;

%% initialize architecture output variables

mean_angle = sum(angle_list, 3)./squeeze(n_points(:,:,2));
mean_angle(isnan(mean_angle)) = 0;

mean_curvature = sum(curvature_list, 3)./n_points(:,:,3);

total_distance = squeeze(max(distance_list, [], 3));

%% implement quality checking algorithm

%1) reject fibers that do not monotonically increase in the Z direction
% qual_mask(:,:,1) = (initial_fibers + ((initial_fibers - bwmorph(initial_fibers,'majority',inf))>0))>0;
% num_tracked(1) = length(find(qual_mask(:,:,1)>0));

z_positions=squeeze(fitted_fiber_all(:,:,:,3));
for row_cntr = first_row:last_row
    
    for col_cntr = first_col:last_col
        
        loop_z=squeeze(z_positions(row_cntr, col_cntr,:));
        loop_dz=diff(loop_z);
        loop_dz=loop_dz(1:(length(find(loop_dz))-1));
        if length(find(loop_dz<0))>0
            qual_mask(row_cntr,col_cntr,1)=0;
        end
        
    end
    
end
num_tracked(1) = length(find(qual_mask(:,:,1)>0));

%2) reject fibers that are too short
too_short = ones(size(total_distance));
too_short(total_distance<min_distance) = 0;
qual_mask(:,:,2) = qual_mask(:,:,1).*too_short;
num_tracked(2) = length(find(qual_mask(:,:,2)>0));

%3) reject fibers that out of bounds pennation angle
negative_angle = ones(size(mean_angle));
negative_angle(mean_angle <= min_pennation) = 0;
negative_angle(mean_angle >= max_pennation) = 0;
qual_mask(:,:,3) = qual_mask(:,:,2).*negative_angle;
num_tracked(3) = length(find(qual_mask(:,:,3)>0));

%4) reject fibers that have excessive curvature
high_curvature = ones(size(mean_curvature));
high_curvature(mean_curvature >= max_curvature) = 0;
qual_mask(:,:,4) = qual_mask(:,:,3).*high_curvature;
num_tracked(4) = length(find(qual_mask(:,:,4)>0));

%6) reject fibers that are very different (>2 SD) from their neighboring pixels in
%   length, curvature, or pennation angle
qual_mask(:,:,5) = qual_mask(:,:,4);
qual_mask(:,:,6) = qual_mask(:,:,4);

for row_cntr = first_row:last_row
    
    for col_cntr = first_col:last_col
        
        if qual_mask(row_cntr,col_cntr,5) == 1
            
            row_neighbors = (row_cntr-2):(row_cntr+2);
            col_neighbors = (col_cntr-2):(col_cntr+2);
            local_fibers = qual_mask(row_neighbors,col_neighbors,4);

            local_angle = mean_angle(row_neighbors, col_neighbors);
            local_angle = local_angle.*local_fibers;
            local_angle_non0 = local_angle(local_angle>0);
            mean_local_angle = mean(local_angle_non0);
            std_local_angle = std(local_angle_non0);
            
            if local_angle(3,3)>(mean_local_angle + 2*std_local_angle) || ...
                    local_angle(3,3)<(mean_local_angle - 2*std_local_angle)
                qual_mask(row_cntr,col_cntr,6) = 0;
            end

            local_curve = mean_curvature(row_neighbors, col_neighbors);
            local_curve = local_curve.*local_fibers;
            local_curve_non0 = local_curve(local_curve>0);
            mean_local_curve = median(local_curve_non0);
            std_local_curve = std(local_curve_non0);
            if local_curve(3,3)>(mean_local_curve + 2*std_local_curve) || ...
                    local_curve(3,3)<(mean_local_curve - 2*std_local_curve)
                qual_mask(row_cntr,col_cntr,6) = 0;
            end

            local_length = total_distance(row_neighbors, col_neighbors);
            local_length = local_length.*local_fibers;
            local_length_non0 = local_length(local_length>0);
            mean_local_length = median(local_length_non0);
            std_local_length = std(local_length_non0);
            if local_length(3,3)>(mean_local_length + 2*std_local_length) || ...
                    local_length(3,3)<(mean_local_length - 2*std_local_length)
                qual_mask(row_cntr,col_cntr,6) = 0;
            end

        end
        
        final_fibers(row_cntr,col_cntr,:,1) = final_fibers(row_cntr,col_cntr,:,1)*qual_mask(row_cntr,col_cntr,6);
        final_fibers(row_cntr,col_cntr,:,2) = final_fibers(row_cntr,col_cntr,:,2)*qual_mask(row_cntr,col_cntr,6);
        final_fibers(row_cntr,col_cntr,:,3) = final_fibers(row_cntr,col_cntr,:,3)*qual_mask(row_cntr,col_cntr,6);
        
        final_curvature(row_cntr,col_cntr,:) = final_curvature(row_cntr,col_cntr,:)*qual_mask(row_cntr,col_cntr,6);
        final_angle(row_cntr,col_cntr,:) = final_angle(row_cntr,col_cntr,:)*qual_mask(row_cntr,col_cntr,6);
        final_distance(row_cntr,col_cntr,:) = final_distance(row_cntr,col_cntr,:)*qual_mask(row_cntr,col_cntr,6);
        
    end
    
end

num_tracked(5) = length(find(qual_mask(:,:,6)>0));
num_tracked=[(last_row-first_row+1)*(last_col-first_col+1) sum(sum(initial_fibers)) num_tracked];
qual_final = qual_mask(:,:,6);
qual_final(isnan(mean_angle)) = 0;
qual_final(isnan(mean_curvature)) = 0;
qual_final(isnan(total_distance)) = 0;
qual_mask(:,:,5) = qual_final;
qual_mask = qual_mask(:,:,1:5);


%% calculate other output variables

%tract-specific properties
mean_curvature = mean_curvature.*qual_mask(:,:,5);
mean_curvature(isnan(mean_curvature)) = 0;                                    %account for division by zero when initially calculating the mean
mean_fiber_properties = mean_curvature;

mean_angle = mean_angle.*qual_mask(:,:,5);
mean_angle(isnan(mean_angle)) = 0;                                            %account for division by zero when initially calculating the mean
mean_fiber_properties(:,:,2) = mean_angle;

total_distance = total_distance.*qual_mask(:,:,5);
mean_fiber_properties(:,:,3) = total_distance;

mean_fiber_properties(:,:,4) = apo_area;

mean_fiber_properties(:,:,5) = n_points(:,:,1);

%aponeurosis-wide properties
mean_apo_properties(1) = sum(sum(mean_curvature.*apo_area.*qual_final))./sum(sum(apo_area.*qual_final));
mean_apo_properties(2) = sum(sum(mean_angle.*apo_area.*qual_final))./sum(sum(apo_area.*qual_final));
mean_apo_properties(3) = sum(sum(total_distance.*apo_area.*qual_final))./sum(sum(apo_area.*qual_final));

%% end the function

return;



